import os
import re
import subprocess
import urllib.parse
from tools.tools import Tools

class ExploitDownloader(Tools):
    """
    Enhanced ExploitDownloader with automatic file extension detection and renaming.
    Downloads exploit code and renames files to proper extensions (.py, .sh, etc.)
    """
    
    def __init__(self):
        super().__init__()
        self.tag = "exploit_downloader"
        self.name = "Exploit Downloader"
        self.description = "Downloads exploit code from exploit-db and other reputable sources"
        
        self.work_dir = getattr(self, 'work_dir', os.path.expanduser('~/agentic_workspace'))
        
        self.exploits_dir = os.path.join(self.work_dir, "exploits")
        os.makedirs(self.exploits_dir, exist_ok=True)
        
        try:
            from core.ui import ui
            self.ui = ui
        except ImportError:
            self.ui = None
        
        self.trusted_domains = [
            'exploit-db.com',
            'github.com',
            'gitlab.com', 
            'raw.githubusercontent.com',
            'gist.githubusercontent.com'
        ]
    
    def detect_file_type_and_rename(self, file_path: str) -> str:
        """Detect file type from content and rename with proper extension"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read(500)  # Read first 500 chars for detection
            
            content_lower = content.lower()
            file_dir = os.path.dirname(file_path)
            base_name = os.path.splitext(os.path.basename(file_path))[0]
            
            new_extension = None
            
            if content.startswith('#!/usr/bin/python') or 'import ' in content or 'def ' in content or 'print(' in content:
                new_extension = '.py'
            elif content.startswith('#!/bin/bash') or content.startswith('#!/bin/sh') or 'echo ' in content:
                new_extension = '.sh'
            elif content.startswith('#!/usr/bin/perl') or 'use strict' in content or '$' in content[:100]:
                new_extension = '.pl'
            elif content.startswith('#!/usr/bin/ruby') or 'require ' in content or 'puts ' in content:
                new_extension = '.rb'
            elif '#include' in content or 'int main(' in content or 'printf(' in content:
                new_extension = '.c'
            elif 'public class' in content or 'import java' in content:
                new_extension = '.java'
            elif 'package main' in content or 'func main()' in content:
                new_extension = '.go'
            else:
                if any(keyword in content_lower for keyword in ['exploit', 'payload', 'shell', 'attack', 'vulnerability']):
                    new_extension = '.py'
                else:
                    new_extension = '.txt'
            
            if new_extension and not file_path.endswith(new_extension):
                new_file_path = os.path.join(file_dir, base_name + new_extension)
                
                mv_cmd = f'mv "{file_path}" "{new_file_path}"'
                result = subprocess.run(mv_cmd, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    return new_file_path
                else:
                    return file_path
            
            return file_path
            
        except Exception as e:
            return file_path
    
    def extract_urls_from_text(self, text: str) -> list:
        """Extract URLs from search results"""
        exploitdb_pattern = r'https?://(?:www\.)?exploit-db\.com/exploits/\d+'
        exploitdb_urls = re.findall(exploitdb_pattern, text, re.IGNORECASE)
        github_raw_pattern = r'https?://raw\.githubusercontent\.com/[^\s<>")]+\.(?:py|sh|txt|c|cpp|java|rb|pl)'
        github_raw_urls = re.findall(github_raw_pattern, text, re.IGNORECASE)
        return exploitdb_urls + github_raw_urls
    
    def download_exploit_db(self, url_or_id: str) -> str:
        """Download from exploit-db using EXACT working logic from test script + file detection"""
        try:
            if url_or_id.isdigit():
                exploit_id = url_or_id
            else:
                exploit_id_match = re.search(r'/exploits/(\d+)', url_or_id)
                if not exploit_id_match:
                    return "Error: Invalid exploit-db URL format"
                exploit_id = exploit_id_match.group(1)
            
            raw_url = f"https://www.exploit-db.com/raw/{exploit_id}"
            temp_file = os.path.join(self.exploits_dir, f"exploit_{exploit_id}.txt")
            
            cmd = f'curl -s "{raw_url}" -o "{temp_file}"'
            
            if self.ui:
                self.ui.thinking(f"Downloading exploit {exploit_id}...")
            
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30,
                cwd=self.exploits_dir
            )
            
            if result.returncode == 0 and os.path.exists(temp_file):
                size = os.path.getsize(temp_file)
                with open(temp_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read(200)
                    if '<html>' in content.lower() or 'not found' in content.lower():
                        os.remove(temp_file)
                        return "Error: Got HTML error page instead of exploit"
                
                final_file = self.detect_file_type_and_rename(temp_file)
                final_filename = os.path.basename(final_file)
                
                with open(final_file, 'r', encoding='utf-8', errors='ignore') as f:
                    preview = f.read(400)
                
                return f"""âœ… Downloaded and processed exploit {exploit_id}
ðŸ“ File: {final_filename} ({size} bytes)
ðŸ“ Location: {final_file}

ðŸ“„ Content preview:
{preview}
{'...' if len(preview) >= 400 else ''}

ðŸŽ¯ Exploit ready for analysis and execution"""
                
            else:
                error_msg = result.stderr if result.stderr else f"Exit code: {result.returncode}"
                return f"Error: Download failed - {error_msg}"
                
        except subprocess.TimeoutExpired:
            return "Error: Download timed out"
        except Exception as e:
            return f"Error: Download exception - {str(e)}"
    
    def download_from_url(self, url: str) -> str:
        """Download from any supported URL with file type detection"""
        if not self.is_trusted_source(url):
            return f"Error: Untrusted source: {url}"
        
        if 'exploit-db.com' in url:
            return self.download_exploit_db(url)
        
        try:
            parsed = urllib.parse.urlparse(url)
            filename = os.path.basename(parsed.path)
            if not filename or '.' not in filename:
                filename = f"download_{hash(url) % 10000}.txt"
            
            temp_file = os.path.join(self.exploits_dir, filename)
            
            cmd = f'curl -s "{url}" -o "{temp_file}"'
            
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30,
                cwd=self.exploits_dir
            )
            
            if result.returncode == 0 and os.path.exists(temp_file):
                size = os.path.getsize(temp_file)
                
                final_file = self.detect_file_type_and_rename(temp_file)
                final_filename = os.path.basename(final_file)
                
                with open(final_file, 'r', encoding='utf-8', errors='ignore') as f:
                    preview = f.read(400)
                
                return f"""âœ… Downloaded and processed file from URL
ðŸ“ File: {final_filename} ({size} bytes)
ðŸ“ Location: {final_file}

ðŸ“„ Content preview:
{preview}
{'...' if len(preview) >= 400 else ''}

ðŸŽ¯ File ready for analysis"""
                
            else:
                return f"Error: Download failed - {result.stderr}"
                
        except Exception as e:
            return f"Error: Download exception - {str(e)}"
    
    def search_and_download(self, search_terms: str) -> str:
        """Search for exploits and download the first good result"""
        if self.ui:
            self.ui.thinking(f"Searching for exploits: {search_terms}")
        
        common_exploits = {
            'apache 2.4.49': ['50383', '50512'],
            'apache 2.4.50': ['50406'],
            'log4j': ['50592', '51183'],
            'apache path traversal': ['50383'],
            'cve-2021-41773': ['50383'],
            'cve-2021-44228': ['50592'],
            'cve-2021-42013': ['50512'],
            'ms17-010': ['42315'],
            'eternalblue': ['42315'],
            'wannacry': ['42315'],
            'smb': ['42315'],
            'windows': ['42315', '39161'],
            'sudo': ['47502'],
            'privilege escalation': ['47502', '39166']
        }
        
        search_lower = search_terms.lower()
        found_ids = []
        
        for pattern, ids in common_exploits.items():
            if pattern in search_lower:
                found_ids.extend(ids)
        
        if found_ids:
            exploit_id = found_ids[0]
            return self.download_exploit_db(exploit_id)
        else:
            return f"""No known exploits found for: {search_terms}

ðŸ’¡ Try these search patterns:
- Specific CVE numbers (e.g., "CVE-2021-41773")
- Service and version (e.g., "Apache 2.4.49")
- Vulnerability names (e.g., "Log4j", "EternalBlue")
- Direct exploit-db URLs

Or provide a specific exploit-db URL to download."""
    
    def is_trusted_source(self, url: str) -> bool:
        """Check if URL is from a trusted source"""
        try:
            parsed = urllib.parse.urlparse(url)
            domain = parsed.netloc.lower()
            return any(trusted in domain for trusted in self.trusted_domains)
        except:
            return False
    
    def execute(self, blocks: list, safety: bool = False) -> str:
        """Execute exploit download operations using working logic with file detection"""
        if not blocks:
            return "Error: No download parameters provided"
        
        output = ""
        
        for block in blocks:
            search_terms = self.get_parameter_value(block, "search_terms")
            url = self.get_parameter_value(block, "url") 
            exploit_id = self.get_parameter_value(block, "exploit_id")
            
            if self.ui:
                self.ui.thinking("Processing exploit download request...")
            
            if url:
                result = self.download_from_url(url)
                output += f"{result}\n\n"
                
            elif exploit_id:
                result = self.download_exploit_db(exploit_id)
                output += f"{result}\n\n"
                
            elif search_terms:
                result = self.search_and_download(search_terms)
                output += f"{result}\n\n"
                
            else:
                urls = self.extract_urls_from_text(block)
                if urls:
                    output += f"Found {len(urls)} URLs in text, downloading first one...\n"
                    download_result = self.download_from_url(urls[0])
                    output += f"{download_result}\n\n"
                else:
                    output += "Error: No search terms, URL, exploit_id, or extractable URLs provided\n\n"
        
        return output.strip()
    
    def execution_failure_check(self, output: str) -> bool:
        """Check if download failed"""
        failure_indicators = [
            "Error:", "Download failed:", "Download exception:", 
            "Untrusted source:", "No known exploits found",
            "HTML error page", "timed out"
        ]
        return any(indicator in output for indicator in failure_indicators)
    
    def interpreter_feedback(self, output: str) -> str:
        """Provide feedback about download operation"""
        if self.execution_failure_check(output):
            return f"[failure] Exploit download failed:\n{output}"
        else:
            return f"[success] Exploit download completed:\n{output}"